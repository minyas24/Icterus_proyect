---
title: "code_basic"
author: "Yasmin Benitez Ortiz"
date: "2025-10-09"
output:
  word_document: default
  html_document: default
---

# **Icterus proyect**

#### Librerías.

Herramienta para gestión de librerías, una de sus funciones es p_load, que revisa si los paquetes están instalados y de no estarlo los carga automáticamente.

```{r}
#install.packages("pacman")
library("pacman")
p_load("tidyverse",
       "readr",
       "here",
       "spThin",
       "readr",
       "dplyr",
       "dendextend")
```

"usethis" automatiza tareas repetitivas entre otras cosas (creación de paquetes, por ejemplo), en este caso la usaré para automatizar la insercción de credenciales GBIF para hacer descargas de bases de datos mayores a 10 000 registros.
Primero se crea un archivo .Renviron, que es un archivo de texto plano que también se puede crear desde el block de notas, aquí lo hago con "usethis::edit_r_environ()", coloco las credenciales y reinicio R para que cargue la información.
La ventaja de esto es que crea el archivo en el formato y lugar correctos para que se pueda acceder al archivo posteriormente desde R, también beneficia la reproducibilidad.

### Credenciales para descarga de GBIF

```{r}
#p_load("usethis")

#usethis::edit_r_environ()

#gbif_user="usuario_gbif"
#gbif_pwd="contraseña_gbif"
#gbif_email="email_gbif"
```

## Consulta y descarga







## [Generación de dendograma]{style="color:blue;"}

"read_csv" (tidy) lee un objeto leyendo la base de datos csv obtenida con la limpieza en openrefine y qgis, %>% (tidy) encadena la operación, pasando el resultado al siguiente proceso con la librería [here]{.underline} para ubicar el archivo

se descartan los vectores (columnas) que no aportan información útil para la creación del clúster aplicando "select" (tidy).

"scale" escala\*\*\* para poder realizar el cálculo de las distancias y se coerciona con "as_tibble" (tidy) para un manejo más limpio de los datos

crea una matriz de distancias por distancias euclidianas con "dist"

"hclust" crea un clúster\_\*\*\*Agrupamiento por ligamiento medio o promedio: calcula todas las disimilitudes por pares entre los elementos del grupo 1 y los elementos del grupo 2, y considera el promedio de estas disimilitudes como la distancia entre los dos grupos.

Al final se coerciona el objeto clustering a dendograma.

```{r}
tbb_dendo <- read_csv(here("R_Bursera", "B_data", "8_B_biflora_R.csv"))%>%
  select(-fid, -gbifID, -species, -month, -year) %>% 
  scale( ) %>% 
  as_tibble() %>%  
  dist( method = "euclidean") %>% 
  hclust(method = "average") %>% 
  as.dendrogram( )

```

## inicia el proceso de exportacion del plot

```{r}
jpeg(file = here("R_Bursera", "B_output", "B8_dendo.jpeg"), width = 1000, height = 500) 
```

Visualización de un dendograma reduciendo el tamaño de las etiquetas, "labels_cex", a un 60%. Las ramas del dendograma se colorea de acuerdo al número de grupos especificado con "k", el color en "orange2"

```{r}

tbb_dendo %>% set( what = "labels_cex", value = 0.6) %>% 
  set( "branches_k_color", k = 1, value = c( "orange2")) %>%
  plot()  
```






#------------Similitud-------
#altura máxima del dendo para calcular
dendro
#asignar un objeto con la altura máxima para la visualización y el cálculo de abline
altura_max <- as.numeric(c(28.12245))

#Etiqueta del eje X para mejor visualización

#Superponer un nuevo eje en porcentaje en el lado derecho
axis(side = 4,                                # 4 = lado derecho del gráfico
     at = seq(0, altura_max, length.out = 11), # Posiciones en el eje original
     labels = paste0(seq(100, 0, by = -10), "%")) # Etiquetas en porcentaje


#calcular el 75%
h <- ((40*altura_max)/100)
h
dendro <- abline(h= h) #genera una linea en la altura especificada

#temina el proceso de exportacion del plot
dev.off()   

#---------Poda del dendograma (separación de clústers)--------

#decidir en base a abline el valor k (numero de clusters)
dendro <- as.dendrogram( clustering) #coerciona el objeto clusterin a dendograma
clusters <-cutree(dendro, k= 7, order_clusters_as_data = FALSE) #crea un objeto tipo integrer y lo corta en el numero K de grupos

plot(color_branches(dendro, k=7),leaflab="none") #genera un dendograma con color con el numero K de clusters indicado


#genera un objeto de tipo data frame usando los clusters "cutree",  se declaran las columnas o vectores
clusters_df <- data.frame(ID = names(clusters), cluster = clusters) 

#crear SÓLO el número de clústers encontrado en abline
cluster1 <- filter(clusters_df, cluster == 1)$ID
cluster2 <- filter(clusters_df, cluster == 2)$ID
cluster3 <- filter(clusters_df, cluster == 3)$ID
cluster4 <- filter(clusters_df, cluster == 4)$ID
cluster5 <- filter(clusters_df, cluster == 5)$ID
cluster6 <- filter(clusters_df, cluster == 6)$ID
cluster7 <- filter(clusters_df, cluster == 7)$ID
cluster8 <- filter(clusters_df, cluster == 8)$ID
cluster9 <- filter(clusters_df, cluster == 9)$ID
cluster10 <- filter(clusters_df, cluster == 10)$ID


table(clusters)  #imprime el numero de obserbaciones que integran cada cluster

#preparación de datos para el archivo txt con filas a descartar (eliminados__dendo_I1)/
#genera una lista de los integrantes de un determinado cluster 
cat(as.character(cluster1[1:42]), quote=FALSE,sep="\n") 
cat(as.character(cluster2[1:2]), quote=FALSE,sep="\n")
cat(as.character(cluster3[1:17]), quote=FALSE,sep="\n")
cat(as.character(cluster4[1:1]), quote=FALSE,sep="\n")
cat(as.character(cluster5[1:5]), quote=FALSE,sep="\n")
cat(as.character(cluster6[1:9]), quote=FALSE,sep="\n")
cat(as.character(cluster7[1:9]), quote=FALSE,sep="\n")
cat(as.character(cluster8[1:2]), quote=FALSE,sep="\n")
cat(as.character(cluster9[1:2]), quote=FALSE,sep="\n")
cat(as.character(cluster10[1:2]), quote=FALSE,sep="\n")



#OPCIONAL------------ generar un nuevo dendograma con los subárboles a la altura dada----------
sub.trees <- cut(dendro, h = 15)
sub.trees$lower
clusterLow <- sub.trees$lower[[2]]
clusterLow %>% set( what = "labels_cex", value = 0.6) %>% set( "branches_k_color", k = 1, value = c( "orange2")) %>% plot()
#-----------------






#-------------creacion de nueva base de datos con filas eliminadas en el filtro dendo-------------------------------------

#crea un objeto leyendo (read_csv) la base de datos csv obtenida con la limpieza en  openrefine y qgis, usa la paqueteria "here" para ubicar el archivo

I_spthin <- read_csv(here("R_Icterus", "I_data", "1_I_abeillei_R.csv"))
numeros_eliminar <- scan(here("R_Icterus", "I_data", "eliminados__dendo_I1.txt"))

I_thin <- I_spthin[-numeros_eliminar, ]





#-----------DENDOGRAMA print cuántos registros se conservaron----------------

# Leer el archivos y contar filas

#lee la base de datos inicial y despues cuenta las filas sin tener encuenta los encabezados
datos_ini_csv <- read_csv(here("R_Icterus", "I_data", "1_I_abeillei_R.csv"))
datos_inicial <- nrow(datos_ini_csv)

#lee el archivo txt generado anteriormente, con las filas a eliminar, y despues cuenta las filas. Se especifica que no tiene encabezados y debe leer desde la primera linea
datos_txt <- read.table(here("R_Icterus", "I_data", "eliminados__dendo_I1.txt"), header = FALSE)
datos_elim <- nrow(datos_txt)

#hace una resta de los objetos para calcular el n'umero de datos posteriores al dendograma
dendo_datos_final <- datos_inicial - datos_elim

print(paste0("Dendograma/ número inicial: ", datos_inicial, ", eliminados: ", datos_elim, ", Número final: ", dendo_datos_final))








#--OPCIONAL-----------------codigo para crear un dendo con la nueva base de datos-----------------------
#crea un objeto llamado "limpio" donde se descartan los vectores (columnas) que no aportan información útil para la creación del clúster
limpio <- I1_thin %>% select(-shapeid, -partid, -x, -y, -fid, -gbifID, -species, -decimalLat, -decimalLon, -month, -year)

#crea un objeto llamado "escalado" escalando el objeto limpio para poder realizar el càlculo de las distancias y coercionándolo a tibble
escalado <- scale( x = limpio) %>% as_tibble()

#crea yna matriz de distancias  por distancias euclidianas
distancia <- dist( x = escalado, method = "euclidean")

#crea un clùster_--Agrupamiento por ligamiento medio o promedio: calcula todas las disimilitudes por pares entre los elementos del grupo 1 y los elementos del grupo 2, y considera el promedio de estas disimilitudes como la distancia entre los dos grupos.
clustering <- hclust( d= distancia, method = "average")


dendro <- as.dendrogram( clustering) #coerciona el objeto clustering a dendograma


dendro %>% set( what = "labels_cex", value = 0.6) %>% set( "branches_k_color", k = 1, value = c( "orange2")) %>% plot()    #crea un plot con las caracteristicas especidficadas
#------------------------------------------




#-------------SpThin-------------------------------------

#install.packages("spThin")----este paquete contiene un conjunto de funciones para realizar el adelgazamiento espacial de registros de ocurrencia lo que busca equilibrar la densidad de registros
library(spThin)

head("I_thin")
plot(I_thin$decimalLon, I_thin$decimalLat,
     xlab = "Longitud",   #etiquetas ejes
     ylab = "Latitud",
     sub = "Icterus abeillei", #subtitulo
     cex.sub = 0.5,   #size sub (50%)
     font.sub = 3)    #fuente sub cursiva (negrita 2/ negrita-cursiva 4)


thin( loc.data = I_thin, #base de datos a procesar, se usa el objeto "I_thin" que contiene la base resultante del filtro dendo
      lat.col =  "x", long.col = "y", 
      spec.col = "shapeid", 
      thin.par = 10, reps = 100, #thin.par: distancia mínima entre puntos en km. reps = repeticiones del proceso de adelgazamiento.
      locs.thinned.list.return = TRUE, #TRUE se genera una lista de cada repetición realizada
      write.files = TRUE, #TRUE genera archivos con extensión csv.
      write.log.file = TRUE,
      out.dir = here("R_Icterus", "I_data", "output_I1_thin" ))



#-----------ADELGAZAMIENTO print cuántos registros se conservaron----------------

# Leer el archivos y contar filas
#se toma el objeto resultado del conteo filtro dendograma
datos_inicial <- dendo_datos_final

#lee el archivo generado en spthin con los datos finales y despues cuenta las filas sin tomar en cuenta encabezados
datos_fin_csv <- read_csv(here("R_Icterus", "I_data", "output_I1_thin","thinned_data_thin1.csv"))
spthin_datos_final <- nrow(datos_fin_csv)

#hace una resta de los objetos para calcular el n'umero de datos posteriores al adelgazamiento
datos_elim <- datos_inicial - spthin_datos_final 

print(paste0("spThin/ Número inicial: ", datos_inicial, ", eliminados: ", datos_elim, ", Número final: ", spthin_datos_final))



#------------------------write id de observaciones conservadas después del adelazamiento---------------
#lectura de registros iniciales con id
thinned_data_thin1 <- read_csv(here("R_Icterus", "I_data","output_I1_thin", "thinned_data_thin1.csv"))
#lectura de resultados de adelgazamiento
inicial <- read_csv(here("R_Icterus", "I_data", "1_I_abeillei_R.csv"))

# join usando las coordenadas y la especie como clave
id_spthin <- thinned_data_thin1 %>%
  left_join(inicial,
            by = c("species" = "species", # "thinned_data_thin1" = "inicial"
                   "x" = "decimalLon" ,
                   "y" = "decimalLat" ))

#Verificar NAs para buscar errores de no coincidencia
which(is.na(id_spthin$fid))


#arreglar formato
colnames(id_spthin)[2] <- "decimalLat"
colnames(id_spthin)[3] <- "decimalLon"
id_spthin <- id_spthin %>% relocate(fid)

#guardar un csv
write_csv(id_spthin, "R_Icterus/I_data/output_I1_thin/id_spthin.csv")


#------------------------puntos adelgazados-------------------------

sthin <- read_csv(here("R_Icterus", "I_data", "output_I1_thin", "thinned_data_thin1.csv"))
points(sthin$x, sthin$y, col = "orange", pch = 20)

library(tidyverse)
library("pacman")
p_load("vroom", "dplyr", "dendextend")
library(readr)
library(cluster)
library(here)
library(spThin)
library(readr)
library("colorspace")
#----------Generación de dendograma------------
I10_dominicensis <- read_csv(here("R_Icterus", "I_data", "10_I_dominicensis_R.csv"))
limpio <- I10_dominicensis %>% select(-fid, -gbifID, -species, -month, -year)
escalado <- scale( x = limpio) %>% as_tibble()
distancia <- dist( x = escalado, method = "euclidean")
clustering <- hclust( d= distancia, method = "average")
dendo <- as_dendrogram( clustering) 

#inicia el proceso de exportacion del plot
png(file = "C:/Users/Yas/OneDrive/Maestría/proyecto/QGis/layers/Icterus_proyect/R_Icterus/I_data/graphics/I_10dendo.png", width = 5000, height = 2000)   

dendo %>% set( what = "labels_cex", value = 0.3) %>% set( "branches_k_color", k = 1, value = c( "orange2")) %>% plot()





#------------Similitud-------
#altura máxima del dendo para calcular
dendo
#asignar un objeto con la altura máxima para la visualización y el cálculo de abline
altura_max <- as.numeric(c(32.45111))

#Etiqueta del eje X para mejor visualización--------------

#Superponer un nuevo eje en porcentaje en el lado derecho
axis(side = 4,                                # 4 = lado derecho del gráfico
     at = seq(0, altura_max, length.out = 11), # Posiciones en el eje original
     labels = paste0(seq(100, 0, by = -10), "%")) # Etiquetas en porcentaje


#temina el proceso de exportacion del plot
dev.off()   


#calcular el 75%
h <- ((25*altura_max)/100)
h
dendo <- abline(h= h) 





#---------Poda del dendograma (separación de clústers)--------

#decidir en base a abline el valor k (numero de clusters)
dendo <- as.dendrogram( clustering)
clusters <-cutree(dendo, k= 5, order_clusters_as_data = FALSE) 

#Opcional -----dendo <-rect.dendrogram(dendo, k = 21)


#opcional
plot(color_branches(dendo, k=5),leaflab="none") #genera un dendograma con color con el numero K de clusters indicado





#crear SÓLO el número de clústers encontrado en abline
clusters_df <- data.frame(ID = names(clusters), cluster = clusters)
cluster1 <- filter(clusters_df, cluster == 1)$ID
cluster2 <- filter(clusters_df, cluster == 2)$ID
cluster3 <- filter(clusters_df, cluster == 3)$ID
cluster4 <- filter(clusters_df, cluster == 4)$ID
cluster5 <- filter(clusters_df, cluster == 5)$ID



table(clusters)  #imprime el numero de obserbaciones que integran cada cluster

#preparación de datos para el archivo txt con filas a descartar (eliminados__dendo_I1)
cat(as.character(cluster1[1]), quote=FALSE,sep="\n") 
cat(as.character(cluster2[1]), quote=FALSE,sep="\n")
cat(as.character(cluster3[1:17]), quote=FALSE,sep="\n")
cat(as.character(cluster4[1:33]), quote=FALSE,sep="\n")

#--OPCIONAL-----------------codigo para crear un dendo con la nueva base de datos-----------------------
sub.trees <- cut(dendo, h = 15)
sub.trees$lower
clusterLow <- sub.trees$lower[[2]]
clusterLow %>% set( what = "labels_cex", value = 0.6) %>% set( "branches_k_color", k = 1, value = c( "orange2")) %>% plot()
#-*******--------------------------------------




#-------------creacion de nueva base de datos con filas eliminadas en el filtro dendo-------------------------------------


I_spthin <- read_csv(here("R_Icterus", "I_data", "10_I_dominicensis_R.csv"))
numeros_eliminar <- scan(here("R_Icterus", "I_data", "eliminados__dendo_I10.txt"))

I_thin <- I_spthin[-numeros_eliminar, ]
I_thin


#-----------DENDOGRAMA print cuántos registros se conservaron----------------

# Leer el archivos y contar filas

datos_ini_csv <- read_csv(here("R_Icterus", "I_data", "10_I_dominicensis_R.csv"))
datos_inicial <- nrow(datos_ini_csv)

datos_txt <- read.table(here("R_Icterus", "I_data", "eliminados__dendo_I10.txt"), header = FALSE)
datos_elim <- nrow(datos_txt)

dendo_datos_final <- datos_inicial - datos_elim

print(paste0("Dendograma/ número inicial: ", datos_inicial, ", eliminados: ", datos_elim, ", Número final: ", dendo_datos_final))



#-------------SpThin-------------------------------------


png(file = "C:/Users/Yas/OneDrive/Maestría/proyecto/QGis/layers/Icterus_proyect/R_Icterus/I_data/graphics/I_10spthin.png", width = 666, height = 740)   

head("I_thin")
plot(I_thin$decimalLon, I_thin$decimalLat,
     xlab = "Longitud", 
     ylab = "Latitud",
     sub = "Icterus dominicensis",
     cex.sub = 0.5,
     font.sub = 3)

thin( loc.data = I_thin,
      lat.col =  "decimalLat", long.col = "decimalLon", 
      spec.col = "species", 
      thin.par = 10, reps = 100, 
      locs.thinned.list.return = TRUE, 
      write.files = TRUE, 
      write.log.file = TRUE,
      out.dir = here("R_Icterus", "I_data", "output_I10_thin" ))





#-----------ADELGAZAMIENTO print cuántos registros se conservaron----------------

# Leer el archivos y contar filas

datos_inicial <- dendo_datos_final

datos_fin_csv <- read_csv(here("R_Icterus", "I_data", "output_I10_thin","thinned_data_thin1.csv"))
spthin_datos_final <- nrow(datos_fin_csv)

datos_elim <- datos_inicial - spthin_datos_final 

print(paste0("spThin/ Número inicial: ", datos_inicial, ", eliminados: ", datos_elim, ", Número final: ", spthin_datos_final))



#------------------------write id de observaciones conservadas después del adelazamiento---------------
#lectura de registros iniciales con id
thinned_data_thin1 <- read_csv(here("R_Icterus", "I_data","output_I10_thin", "thinned_data_thin1.csv"))
#lectura de resultados de adelgazamiento
inicial <- read_csv(here("R_Icterus", "I_data", "10_I_dominicensis_R.csv"))

# join usando las coordenadas y la especie como clave
id_spthin <- thinned_data_thin1 %>% 
  left_join(inicial,
            by = c("species" = "species",
                   "decimalLon" = "decimalLon",
                   "decimalLat" = "decimalLat" )) # "thinned_data_thin1" = "inicial"

#Verificar NAs para buscar errores de no coincidencia
which(is.na(id_spthin$fid))


#arreglar formato
colnames(id_spthin)[2] <- "decimalLat"
colnames(id_spthin)[3] <- "decimalLon"
id_spthin <- id_spthin %>% relocate(fid)

#guardar un csv
write_csv(id_spthin, "R_Icterus/I_data/output_I10_thin/id_spthin.csv")




#------------------------puntos adelgazados-------------------------

sthin <- read_csv(here("R_Icterus", "I_data", "output_I10_thin", "thinned_data_thin1.csv"))
points(sthin$decimalLon, sthin$decimalLat, col = "orange", pch = 20)
dev.off()



## 
